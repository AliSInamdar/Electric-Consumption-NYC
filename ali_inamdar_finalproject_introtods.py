# -*- coding: utf-8 -*-
"""Ali_Inamdar_FinalProject_IntroToDS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-mjkGS8S4l-AVuSmXzq__L3-sDfCMu1-

## Introduction to Data Science - CS 675.

## Inamdar Ali

## Final Project - Times Series Forecasting

Importing all libraries:
"""

import pandas as pd
import numpy as np
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, r2_score
import matplotlib.pyplot as plt
import seaborn as sns

"""Importing the dataset and converting into a data frame using pandas."""

data1 = pd.read_csv('//content/Electric_Consumption_And_Cost__2010_-_Feb_2023__20241125.csv')

data1

"""## Data PreProcessing , cleaning and Wrangling."""

data1.columns

data1.info()

data1.columns

data1.describe()

data1.rename(columns={"Service Start Date": "ds", "Consumption (KWH)": "y"}, inplace=True)

print("\nChecking for Missing Values:")
print(data1.isnull().sum())

numerical_data = data1.select_dtypes(include=np.number)

# Convert 'ds' column to datetime objects
data1['ds'] = pd.to_datetime(data1['ds'])

"""## Exploratory Data Analysis:"""

plt.figure(figsize=(12, 6))

# Convert 'ds' column to strings for plotting
# Assuming 'ds' column contains datetime objects, format them as strings
# If 'ds' contains numerical representations, adjust the formatting accordingly
# Convert the x-axis values to strings explicitly
x_values = data1["ds"].dt.strftime('%Y-%m-%d').astype(str)

plt.plot(x_values, data1["y"], label="Electricity Consumption (KWH)", color="blue")
plt.plot(x_values, data1['Current Charges'], label="Current Charges", color="green")
plt.plot(x_values, data1["Consumption (KW)"], label="Consumption (KW)", color="red")

plt.title("Electricity Consumption, Charges, and Consumption (KW) Over Time")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()

# Plot the time series of other key variables
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Electricity Consumption (KWH)", color="blue")
plt.plot(data1["ds"], data1['Current Charges'], label="Current Charges", color="green")
plt.plot(data1["ds"], data1["Consumption (KW)"], label="Consumption (KW)", color="red")
plt.title("Electricity Consumption, Charges, and Consumption (KW) Over Time")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()

# Box plot for detecting outliers in "Consumption (KWH)" and "Current Charges"
plt.figure(figsize=(12, 6))
sns.boxplot(data=data1[["y", 'Current Charges']])
plt.title("Box Plot of Consumption (KWH) and Current Charges")
plt.ylabel("Value")
plt.show()

# Distribution of "Consumption (KWH)" to check the skewness
plt.figure(figsize=(12, 6))
sns.histplot(data1["y"], bins=50, kde=True, color="blue")
plt.title("Distribution of Electricity Consumption (KWH)")
plt.xlabel("Consumption (KWH)")
plt.ylabel("Frequency")
plt.show()

# Distribution of "Current Charges"
plt.figure(figsize=(12, 6))
sns.histplot(data1["Current Charges"], bins=50, kde=True, color="green")
plt.title("Distribution of Current Charges")
plt.xlabel("Current Charges")
plt.ylabel("Frequency")
plt.show()

# Time series of "Current Charges" vs "Consumption (KWH)"
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["Current Charges"], label="Current Charges", color="green")
plt.plot(data1["ds"], data1["y"], label="Consumption (KWH)", color="blue")
plt.title("Current Charges vs Consumption (KWH) Over Time")
plt.xlabel("Date")
plt.ylabel("Value")
plt.legend()
plt.show()

# Plotting the time series
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Electricity Consumption (KWH)")
plt.title("Electricity Consumption Over Time")
plt.xlabel("Date")
plt.ylabel("Consumption (KWH)")
plt.legend()
plt.show()

# Plotting distribution of values
plt.figure(figsize=(12, 6))
plt.hist(data1["y"], bins=50, color="blue", alpha=0.7)
plt.title("Distribution of Electricity Consumption (KWH)")
plt.xlabel("Consumption (KWH)")
plt.ylabel("Frequency")
plt.show()

"""## FBProphet Model:"""

# Determine the time unit of the dataset
date_diff = (data1["ds"].iloc[1] - data1["ds"].iloc[0]).days
time_unit = "daily" if date_diff == 1 else "monthly" if 28 <= date_diff <= 31 else "yearly"

data1['ds'] = pd.to_datetime(data1['ds'])

# Aggregate the dataset by specified time unit, excluding non-numeric columns
if time_unit == "monthly":
    data1 = data1.resample("M", on="ds")[['y']].mean().reset_index()  # Select only 'y'
elif time_unit == "yearly":
    data1 = data1.resample("Y", on="ds")[['y']].mean().reset_index()  # Select only 'y'

# Train Prophet model and forecast future data1
future_periods = 365 if time_unit == "daily" else 9 if time_unit == "monthly" else 20
model = Prophet()

# Add manual seasonality based on time unit
if time_unit == "daily":
    model.add_seasonality(name="daily_seasonality", period=1, fourier_order=3)
elif time_unit == "monthly":
    model.add_seasonality(name="monthly_seasonality", period=30.5, fourier_order=5)
elif time_unit == "yearly":
    model.add_seasonality(name="yearly_seasonality", period=365.25, fourier_order=10)

"""Fitting the model"""

model.fit(data1)
future = model.make_future_dataframe(periods=future_periods, freq={"daily": "D", "monthly": "M", "yearly": "Y"}[time_unit])
forecast = model.predict(future)

"""Evaluating the model"""

# Evaluate model performance
mae = mean_absolute_error(data1["y"], forecast["yhat"][:len(data1)])
mape = mean_absolute_percentage_error(data1["y"], forecast["yhat"][:len(data1)])
r2 = r2_score(data1["y"], forecast["yhat"][:len(data1)])
print(f"Model Evaluation:\nMAE: {mae}\nMAPE: {mape}\nR^2: {r2}")

"""Printing the results:"""

#Printing the dredicted values
print("Forecasted Values:")
print(forecast[["ds", "yhat"]])

"""Graphical representation of the results and predictions:"""

# Plot historical and forecasted data1
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Historical Data")
plt.plot(forecast["ds"], forecast["yhat"], label="Forecast", color="orange")
plt.fill_between(forecast["ds"], forecast["yhat_lower"], forecast["yhat_upper"], color="orange", alpha=0.3, label="Confidence Interval")
plt.legend()
plt.show()

# Define forecast periods for 1, 10, and 20 years
forecast_periods = {
    "daily": [365, 3650, 7300],  # 1 year, 10 years, 20 years in days
    "monthly": [12, 120, 240],   # 1 year, 10 years, 20 years in months
    "yearly": [1, 10, 20]        # 1 year, 10 years, 20 years in years
}

# Select the appropriate periods based on the time unit
if time_unit == "daily":
    periods_1_year, periods_10_years, periods_20_years = forecast_periods["daily"]
elif time_unit == "monthly":
    periods_1_year, periods_10_years, periods_20_years = forecast_periods["monthly"]
elif time_unit == "yearly":
    periods_1_year, periods_10_years, periods_20_years = forecast_periods["yearly"]

# Initialize the Prophet model
model1 = Prophet()

# Add seasonality based on time unit
if time_unit == "daily":
    model1.add_seasonality(name="daily_seasonality", period=1, fourier_order=3)
elif time_unit == "monthly":
    model1.add_seasonality(name="monthly_seasonality", period=30.5, fourier_order=5)
elif time_unit == "yearly":
    model1.add_seasonality(name="yearly_seasonality", period=365.25, fourier_order=10)

# Fit the model to the data
model1.fit(data1)

# Forecast for 1, 10, and 20 years
future_1_year = model.make_future_dataframe(periods=periods_1_year, freq={"daily": "D", "monthly": "M", "yearly": "Y"}[time_unit])
forecast_1_year = model.predict(future_1_year)

"""Forecast for 10 years:"""

#printing forecast for 10 years
print("Forecast for 10 Years:")
print(forecast_1_year[["ds", "yhat"]])

future_10_years = model.make_future_dataframe(periods=periods_10_years, freq={"daily": "D", "monthly": "M", "yearly": "Y"}[time_unit])
forecast_10_years = model.predict(future_10_years)

"""Forecast for 10 years:"""

#Printing forcast for 10 years
print("Forecast for 10 Years:")
print(forecast_10_years[["ds", "yhat"]])

"""Forecast for 20 years:"""

future_20_years = model.make_future_dataframe(periods=periods_20_years, freq={"daily": "D", "monthly": "M", "yearly": "Y"}[time_unit])
forecast_20_years = model.predict(future_20_years)

#printing forecast for 20 years
print("Forecast for 20 Years:")
print(forecast_20_years[["ds", "yhat"]])

"""Displaying all prediction 1, 10 and 20 years"""

# Displaying the predictions
print("Forecast for 1 Year:")
print(forecast_1_year[["ds", "yhat"]].tail())

# Display predictions for 10 years
print("\nForecast for 10 Years:")
print(forecast_10_years[["ds", "yhat"]].tail())

# Display predictions for 20 years
print("\nForecast for 20 Years:")
print(forecast_20_years[["ds", "yhat"]].tail())

"""Graphical representation of forecast for 1, 10 and 20 years:"""

# Plot forecasts for 1, 10, and 20 years
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Historical Data")
plt.plot(forecast_1_year["ds"], forecast_1_year["yhat"], label="1-Year Forecast", color="orange")
plt.plot(forecast_10_years["ds"], forecast_10_years["yhat"], label="10-Year Forecast", color="green")
plt.plot(forecast_20_years["ds"], forecast_20_years["yhat"], label="20-Year Forecast", color="blue")

plt.fill_between(forecast_1_year["ds"], forecast_1_year["yhat_lower"], forecast_1_year["yhat_upper"], color="orange", alpha=0.3, label="1-Year Confidence Interval")
plt.fill_between(forecast_10_years["ds"], forecast_10_years["yhat_lower"], forecast_10_years["yhat_upper"], color="green", alpha=0.3, label="10-Year Confidence Interval")
plt.fill_between(forecast_20_years["ds"], forecast_20_years["yhat_lower"], forecast_20_years["yhat_upper"], color="blue", alpha=0.3, label="20-Year Confidence Interval")

plt.legend()
plt.title(f"Electricity Consumption Forecast for 1, 10, and 20 Years")
plt.xlabel("Date")
plt.ylabel("Consumption (KWH)")
plt.show()

# Plot 1-Year Forecast
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Historical Data")
plt.plot(forecast_1_year["ds"], forecast_1_year["yhat"], label="1-Year Forecast", color="orange")
plt.fill_between(forecast_1_year["ds"], forecast_1_year["yhat_lower"], forecast_1_year["yhat_upper"], color="orange", alpha=0.3, label="1-Year Confidence Interval")
plt.legend()
plt.title("Electricity Consumption Forecast - 1 Year")
plt.xlabel("Date")
plt.ylabel("Consumption (KWH)")
plt.show()

# Plot 10-Year Forecast
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Historical Data")
plt.plot(forecast_10_years["ds"], forecast_10_years["yhat"], label="10-Year Forecast", color="green")
plt.fill_between(forecast_10_years["ds"], forecast_10_years["yhat_lower"], forecast_10_years["yhat_upper"], color="green", alpha=0.3, label="10-Year Confidence Interval")
plt.legend()
plt.title("Electricity Consumption Forecast - 10 Years")
plt.xlabel("Date")
plt.ylabel("Consumption (KWH)")
plt.show()

# Plot 20-Year Forecast
plt.figure(figsize=(12, 6))
plt.plot(data1["ds"], data1["y"], label="Historical Data")
plt.plot(forecast_20_years["ds"], forecast_20_years["yhat"], label="20-Year Forecast", color="blue")
plt.fill_between(forecast_20_years["ds"], forecast_20_years["yhat_lower"], forecast_20_years["yhat_upper"], color="blue", alpha=0.3, label="20-Year Confidence Interval")
plt.legend()
plt.title("Electricity Consumption Forecast - 20 Years")
plt.xlabel("Date")
plt.ylabel("Consumption (KWH)")
plt.show()

"""## Extra credit:

## Forecasting for all 5 boroughs individually
"""

# List of the 5 boroughs in NYC
boroughs = ['Manhattan', 'Brooklyn', 'Queens', 'Bronx', 'Staten Island']

# Initialize an empty dictionary to store results for each borough
results = {}

# List of boroughs
boroughs = data1['Borough'].unique()

data1.rename(columns={"Service Start Date": "ds", "Consumption (KWH)": "y"}, inplace=True)

data1.rename(columns={"ds1": "Service Start Date"}, inplace=True)

data1.columns

# Loop through each borough
for borough in boroughs:
    print(f"\n--- Predicting for {borough} ---")

    # Filter data for the current borough
    borough_data = data1[data1['Borough'] == borough].copy()

    # Drop rows with missing values in the 'ds' column
    borough_data.dropna(subset=['ds'], inplace=True)  # Add this line to drop NaNs

    # Drop missing values and aggregate by day
    #borough_data = borough_data.groupby('ds')['y'].sum().reset_index()

    # Fit the Prophet model
    model = Prophet(yearly_seasonality=True, growth='linear')
    model.fit(borough_data)

    # Create a dataframe for future predictions (next 365 days)
    future = model.make_future_dataframe(periods=365, freq='D')
    forecast = model.predict(future)

    # Plot the forecast
    fig = model.plot(forecast)
    plt.title(f"Electricity Consumption Forecast for {borough}")
    plt.show()

    # Evaluate the model
    y_true = borough_data['y']
    y_pred = forecast.loc[:len(y_true)-1, 'yhat']